EINGABEN
  jobs: Dictionary<JobID → Liste von Operationen>
        Operation = (Maschine M, Dauer p)
        Beispiel: jobs[1] = [(M1,2), (M2,5), (M3,4)]

  prev_start: Dictionary<(JobID,OpIndex) → bevorzugte_Stundenzeit>
              (Vorplan / Vortag; z.B. 1.0 = 01:00 Uhr)

  prev_seq_per_machine: Dictionary<Maschine → Liste von (JobID,OpIndex) in Vorplan-Reihenfolge>

  Parameter:
    USE_CYCLIC_TOD: Bool (vergleiche Uhrzeiten zyklisch, z.B. 01:00 ≈ 01:00 am Folgetag)
    DAY_PERIOD: Zahl (z.B. 24 für Stunden im Tag)
    W_TIME: Gewicht für Plan-Treue (Zeitnähe)
    W_SEQ:  Gewicht für Reihenfolge-Treue (MinInv-Nähe)

DATENSTRUKTUREN
  machines: Dictionary<Maschine → Freigabezeit>, initial für alle M = 0
  S: Menge/Liste aktuell einplanbarer Operationen, initial: erste Op jedes Jobs → (j,0)
  t: Dictionary<(j,i) → früheste Startzeit>, initial 0 für alle Ops
  start_times, end_times: Dictionary<(j,i) → Start bzw. Ende>, initial leer

HILFSFUNKTIONEN
  cyclic_distance(x, y, period):
    a = (x - y) mod period
    b = (y - x) mod period
    return min(a, b)

  time_deviation_cost(cand_start, pref, use_cyclic, period):
    wenn pref fehlt → 0
    sonst wenn use_cyclic → return cyclic_distance(cand_start, pref, period)
    sonst → return |cand_start - pref|

  seq_position_cost(m, op, prev_seq_per_machine):
    wenn op in prev_seq_per_machine[m]:
      return Position(op) in dieser Liste  (0 = ganz vorne → besser)
    sonst:
      return sehr große Zahl (z.B. 10^6)

HAUPTSCHLEIFE (Giffler–Thompson)
  solange S nicht leer:
    # 1) Früheste Fertigstellung d(o) für alle aktuell einplanbaren Ops o in S
    d = leeres Dictionary
    für jede o = (j,i) in S:
      (m,p) = jobs[j][i]
      earliest_start = max( t[(j,i)], machines[m] )
      d[o] = earliest_start + p

    # 2) Bestimme kleinste Fertigstellung dmin und zugehörige Maschine
    omin = argmin_o d[o]
    dmin = d[omin]
    mach_min = Maschine(jobs[omin])

    # 3) Konfliktmenge K auf dieser Maschine:
    #    alle einplanbaren Ops, die auf mach_min laufen und (früheste Startzeit < dmin)
    K = { o=(j,i) in S | jobs[j][i].M == mach_min und t[(j,i)] < dmin }

    # 4) Auswahlregel (Plan-Treue → Reihenfolge-Treue → KOZ Tiebreak)
    #    Score(o) = ( W_TIME * Zeitabweichung, W_SEQ * Reihenfolgekosten, p )
    #    → lexikographisch minimieren
    o_bar = argmin_o∈K ( 
              W_TIME * time_deviation_cost( max(t[o], machines[M(o)]), prev_start.get(o), USE_CYCLIC_TOD, DAY_PERIOD ),
              W_SEQ  * seq_position_cost( M(o), o, prev_seq_per_machine ),
              p(o)   # KOZ
            )

    # 5) Einplanen von o_bar
    (j_bar,i_bar) = o_bar
    (m_bar,p_bar) = jobs[j_bar][i_bar]
    start = max( t[(j_bar,i_bar)], machines[m_bar] )
    ende  = start + p_bar
    start_times[o_bar] = start
    end_times[o_bar]   = ende
    machines[m_bar]    = ende

    # 6) t-Update für alle anderen Kandidaten derselben Konfliktmenge (rechts schieben)
    für o in K \ {o_bar}:
      t[o] = ende

    # 7) Nachfolgertechnologie freischalten
    wenn i_bar + 1 < Anzahl Operationen von Job j_bar:
      S ← S ∪ { (j_bar, i_bar+1) }
      t[(j_bar, i_bar+1)] = ende   # Nachfolger kann erst nach Ende starten

    # 8) Eingeplante Operation aus S entfernen
    S ← S \ { o_bar }

AUSGABEN
  start_times, end_times → konkreter Ablaufplan
  Makespan = max_end = max{ end_times[o] für alle o }

OPTIONAL: Gantt-Diagramme
  Erzeuge DataFrame df_prev aus prev_start (Start = prev_start[(j,i)], Ende = Start + Dauer)
  Erzeuge DataFrame df_current aus start_times/end_times
  Zeichne jeweils pro Maschine horizontale Balken [Start,Ende)
  (Speichere als PDF oder zeige an)


Erklärung der Idee (kurz & knackig)

Giffler–Thompson (GT) baut sukzessiv einen aktiven Ablaufplan:
In jedem Schritt wird die Operation mit der kleinsten „frühestmöglichen Fertigstellung“ identifiziert, und auf deren Maschine lösen wir den Konflikt.

Konfliktmenge K (nur diese Maschine):
Alle einplanbaren Operationen, die vor dmin starten könnten, konkurrieren um den Slot.

Minimalinvasiv (= Plan-Treue & MinInv nah am Vorplan):

Plan-Treue: Wir wollen die Startzeit möglichst nah an der Vorplan-Uhrzeit halten
→ time_deviation_cost (zyklisch möglich: 01:00 bleibt nah an 01:00 am Folgetag).

MinInv-Gefühl: Wir versuchen, die Vorplan-Reihenfolge der Maschine zu bewahren
→ seq_position_cost (frühere Position = kleinerer Score).

KOZ als Tiebreak, damit wir deterministic bleiben und nicht schlechter werden.

Score-Tupel (lexikographisch):
(W_TIME * Zeitabweichung, W_SEQ * Reihenfolgekosten, p)
→ Minimiert zuerst die Plan-Treue, dann die Reihenfolge, am Ende Bearbeitungszeit.

Updates:
Wird eine Operation eingeplant, verschieben wir alle anderen Kandidaten derselben Maschine rechts hinter deren Ende (t[o] = ende). So entsteht die Maschine-Sequenz. Der Nachfolger des gewählten Jobs wird als einplanbar freigeschaltet.

Ergebnis:
Ein neuer Tagesplan, der möglichst wenig vom Vortag abweicht (Startzeiten/Sequenzen) und dennoch GT-gültig ist.

Feineinstellungen & Hinweise

W_TIME, W_SEQ:

Mehr Plan-Treue → W_TIME erhöhen.

Mehr Reihenfolge-Treue (MinInv-Nähe) → W_SEQ leicht erhöhen.

Typisch: W_TIME deutlich größer als W_SEQ, damit „Startzeit-Treue“ dominiert.

USE_CYCLIC_TOD:

True: vergleicht Uhrzeit unabhängig vom Kalendertag (1 Uhr bleibt 1 Uhr).

False: vergleicht absolute Zeit (z. B. Stundenachse über mehrere Tage).

Fehlende Vorplan-Infos:
Fehlen Einträge in prev_start oder in prev_seq_per_machine, fällt die Auswahl automatisch auf die vorhandenen Kriterien zurück (und am Ende auf KOZ).

Komplexität (intuitiv):
Pro Schritt scanning der Konfliktmenge (klein) + Dictionary-Ops → flott für mittelgroße Instanzen; GT bleibt heuristisch/polynomiell.